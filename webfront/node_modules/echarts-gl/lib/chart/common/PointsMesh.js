"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _graphicGL = require("../../util/graphicGL");

var _verticesSortMixin = require("../../util/geometry/verticesSortMixin");

var echarts = require("echarts/index.blank");

var _glmatrix = require("claygl/src/dep/glmatrix");

var _sdfSpriteGlsl = require("./sdfSprite.glsl.js");

var vec4 = _glmatrix.default.vec4;

_graphicGL.default.Shader.import(_sdfSpriteGlsl.default);

var PointsMesh = _graphicGL.default.Mesh.extend(function () {
  var geometry = new _graphicGL.default.Geometry({
    dynamic: true,
    attributes: {
      color: new _graphicGL.default.Geometry.Attribute('color', 'float', 4, 'COLOR'),
      position: new _graphicGL.default.Geometry.Attribute('position', 'float', 3, 'POSITION'),
      size: new _graphicGL.default.Geometry.Attribute('size', 'float', 1),
      prevPosition: new _graphicGL.default.Geometry.Attribute('prevPosition', 'float', 3),
      prevSize: new _graphicGL.default.Geometry.Attribute('prevSize', 'float', 1)
    }
  });
  Object.assign(geometry, _verticesSortMixin.default);
  var material = new _graphicGL.default.Material({
    shader: _graphicGL.default.createShader('ecgl.sdfSprite'),
    transparent: true,
    depthMask: false
  });
  material.enableTexture('sprite');
  material.define('both', 'VERTEX_COLOR');
  material.define('both', 'VERTEX_SIZE');
  var sdfTexture = new _graphicGL.default.Texture2D({
    image: document.createElement('canvas'),
    flipY: false
  });
  material.set('sprite', sdfTexture); // Custom pick methods.

  geometry.pick = this._pick.bind(this);
  return {
    geometry: geometry,
    material: material,
    mode: _graphicGL.default.Mesh.POINTS,
    sizeScale: 1
  };
}, {
  _pick: function (x, y, renderer, camera, renderable, out) {
    var positionNDC = this._positionNDC;

    if (!positionNDC) {
      return;
    }

    var viewport = renderer.viewport;
    var ndcScaleX = 2 / viewport.width;
    var ndcScaleY = 2 / viewport.height; // From near to far. indices have been sorted.

    for (var i = this.geometry.vertexCount - 1; i >= 0; i--) {
      var idx;

      if (!this.geometry.indices) {
        idx = i;
      } else {
        idx = this.geometry.indices[i];
      }

      var cx = positionNDC[idx * 2];
      var cy = positionNDC[idx * 2 + 1];
      var size = this.geometry.attributes.size.get(idx) / this.sizeScale;
      var halfSize = size / 2;

      if (x > cx - halfSize * ndcScaleX && x < cx + halfSize * ndcScaleX && y > cy - halfSize * ndcScaleY && y < cy + halfSize * ndcScaleY) {
        var point = new _graphicGL.default.Vector3();
        var pointWorld = new _graphicGL.default.Vector3();
        this.geometry.attributes.position.get(idx, point.array);

        _graphicGL.default.Vector3.transformMat4(pointWorld, point, this.worldTransform);

        out.push({
          vertexIndex: idx,
          point: point,
          pointWorld: pointWorld,
          target: this,
          distance: pointWorld.distance(camera.getWorldPosition())
        });
      }
    }
  },
  updateNDCPosition: function (worldViewProjection, is2D, api) {
    var positionNDC = this._positionNDC;
    var geometry = this.geometry;

    if (!positionNDC || positionNDC.length / 2 !== geometry.vertexCount) {
      positionNDC = this._positionNDC = new Float32Array(geometry.vertexCount * 2);
    }

    var pos = vec4.create();

    for (var i = 0; i < geometry.vertexCount; i++) {
      geometry.attributes.position.get(i, pos);
      pos[3] = 1;
      vec4.transformMat4(pos, pos, worldViewProjection.array);
      vec4.scale(pos, pos, 1 / pos[3]);
      positionNDC[i * 2] = pos[0];
      positionNDC[i * 2 + 1] = pos[1];
    }
  }
});

var _default = PointsMesh;
exports.default = _default;